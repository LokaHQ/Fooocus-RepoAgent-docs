## ClassDef UpscaleModelLoader
**UpscaleModelLoader**: The function of UpscaleModelLoader is to load an upscale model based on the provided model name.

**attributes**: The attributes of this Class.
· INPUT_TYPES: A class method that defines the required input types for loading the model, specifically the model name.
· RETURN_TYPES: A tuple indicating the type of output returned by the load_model function, which is "UPSCALE_MODEL".
· FUNCTION: A string that specifies the name of the function responsible for loading the model, which is "load_model".
· CATEGORY: A string that categorizes this class under "loaders".

**Code Description**: The UpscaleModelLoader class is designed to facilitate the loading of upscale models in a structured manner. It contains a class method INPUT_TYPES that specifies the required input for the model loading process. This input is a dictionary that mandates the "model_name", which is retrieved from a list of available upscale models using the utility function ldm_patched.utils.path_utils.get_filename_list("upscale_models"). 

The class also defines RETURN_TYPES, which indicates that the output of the load_model method will be of type "UPSCALE_MODEL". The FUNCTION attribute specifies that the primary function of this class is "load_model". The CATEGORY attribute classifies this loader under the "loaders" category.

The core functionality is encapsulated in the load_model method, which takes a single parameter, model_name. This method constructs the full path to the model file using ldm_patched.utils.path_utils.get_full_path, passing in the directory "upscale_models" and the model name. It then loads the model's state dictionary using ldm_patched.modules.utils.load_torch_file, ensuring safe loading by setting safe_load=True.

If the loaded state dictionary contains a specific key indicating the presence of a module prefix, the method removes this prefix using ldm_patched.modules.utils.state_dict_prefix_replace. Finally, the method loads the state dictionary into a model instance using model_loading.load_state_dict and sets the model to evaluation mode with eval(). The method returns a tuple containing the loaded model instance.

**Note**: It is important to ensure that the model name provided exists in the list of available upscale models. The loading process may fail if the model file is not found or if the state dictionary is not compatible with the expected model architecture.

**Output Example**: A possible return value from the load_model method could be a tuple containing a loaded model instance, such as:
(out,) where 'out' is an instance of the upscale model ready for inference.
### FunctionDef INPUT_TYPES(s)
**INPUT_TYPES**: The function of INPUT_TYPES is to define the required input parameters for the model loader, specifically the model name.

**parameters**: The parameters of this Function.
· s: This parameter is a placeholder that is typically used to represent the state or context in which the function is called, although it is not utilized within the function itself.

**Code Description**: The INPUT_TYPES function returns a dictionary that specifies the required input for the model loader. The dictionary contains a single key, "required", which maps to another dictionary. This inner dictionary has one key, "model_name", which is associated with a tuple. The tuple is generated by calling the function ldm_patched.utils.path_utils.get_filename_list with the argument "upscale_models". This indicates that the model_name input is expected to be one of the filenames retrieved from the "upscale_models" directory.

The INPUT_TYPES function is designed to facilitate the dynamic retrieval of available model names, ensuring that the loader can operate with the most current data. By leveraging the get_filename_list function, it ensures that the model names are not hardcoded, allowing for flexibility and adaptability in the model loading process.

The relationship with its callees is significant; the INPUT_TYPES function is often invoked by various components within the project that require knowledge of the available upscale models. This allows those components to validate user input against the dynamically retrieved list of model names, enhancing the robustness of the application.

**Note**: When using this function, it is important to ensure that the "upscale_models" directory exists and contains valid model files. The function relies on the proper configuration of the directory structure to function correctly.

**Output Example**: An example of the return value from INPUT_TYPES could be:
```
{"required": { "model_name": (['model1.pt', 'model2.pt', 'model3.pt'], )}}
```
***
### FunctionDef load_model(self, model_name)
**load_model**: The function of load_model is to load a specified upscale model based on its name from a given path and return the model ready for evaluation.

**parameters**: The parameters of this Function.
· model_name: A string representing the name of the model to be loaded.

**Code Description**: The load_model function is responsible for loading an upscale model by first determining the full path of the model file using the provided model_name. It utilizes the get_full_path function from the ldm_patched.utils.path_utils module to construct the complete file path by searching within the "upscale_models" directory. If the model file exists, it proceeds to load the model's state dictionary using the load_torch_file function from the ldm_patched.modules.utils module, with safe loading enabled.

Once the state dictionary is loaded, the function checks if a specific key ("module.layers.0.residual_group.blocks.0.norm1.weight") exists within the state dictionary. If this key is present, it indicates that the state dictionary has a prefix that needs to be removed. The function then calls state_dict_prefix_replace to remove the "module." prefix from the keys in the state dictionary, ensuring compatibility with the model architecture.

After processing the state dictionary, the function calls load_state_dict from the ldm_patched.pfn.model_loading module to load the model weights into the appropriate model architecture. The loaded model is then set to evaluation mode by calling the eval() method, preparing it for inference.

The load_model function is integral to the UpscaleModelLoader class, facilitating the loading of various upscale models for image processing tasks. It ensures that the models are correctly loaded and ready for use by managing the state dictionary and handling any necessary modifications to the keys.

**Note**: It is essential to ensure that the model_name provided corresponds to an existing model file in the "upscale_models" directory. Additionally, the function assumes that the loaded state dictionary is compatible with the expected model architecture.

**Output Example**: A possible return value from load_model could be a tuple containing the loaded model object, such as (RealESRGANv2_model_instance,).
***
## ClassDef ImageUpscaleWithModel
**ImageUpscaleWithModel**: The function of ImageUpscaleWithModel is to upscale images using a specified model.

**attributes**: The attributes of this Class.
· INPUT_TYPES: Specifies the required input types for the class method, including the upscale model and the image to be processed.  
· RETURN_TYPES: Defines the return type of the upscale method, which is an image.  
· FUNCTION: Indicates the name of the function that performs the upscaling operation, which is "upscale".  
· CATEGORY: Categorizes the functionality of the class under "image/upscaling".

**Code Description**: The ImageUpscaleWithModel class is designed to facilitate the upscaling of images using a specified machine learning model. It contains a class method INPUT_TYPES that defines the required inputs: an upscale model of type "UPSCALE_MODEL" and an image of type "IMAGE". The class also specifies that the output of the upscale operation will be of type "IMAGE".

The core functionality is encapsulated in the upscale method, which takes the upscale model and the image as parameters. Within this method, the following steps are executed:

1. The method retrieves the appropriate device for processing (CPU or GPU) using model_management.get_torch_device() and transfers the upscale model to that device.
2. The input image is rearranged to match the expected format for processing and moved to the same device.
3. The method checks for available memory on the device using model_management.get_free_memory(device).
4. It initializes parameters for tiling the image, specifically setting the tile size to 512 and overlap to 32.
5. A loop is implemented to handle out-of-memory (OOM) exceptions. If an OOM exception occurs during processing, the tile size is halved until it reaches a minimum threshold of 128.
6. The method calculates the number of processing steps required based on the dimensions of the input image and the tiling parameters.
7. A progress bar is instantiated to provide feedback during the processing.
8. The image is processed in tiles using the tiled_scale function, which applies the upscale model to each tile while managing the overlap and upscale amount.
9. After processing, the upscale model is moved back to the CPU, and the output image is clamped to ensure pixel values are within the valid range (0 to 1).

The ImageUpscaleWithModel class is likely called by other components in the project, such as modules/upscaler.py, where it may be utilized to upscale images as part of a larger image processing workflow. This integration allows for enhanced image resolution, leveraging the capabilities of machine learning models for better visual quality.

**Note**: It is important to ensure that the upscale model is compatible with the input image format and that sufficient memory is available on the processing device to avoid OOM exceptions during execution.

**Output Example**: A possible appearance of the code's return value could be a tensor representing the upscaled image, with dimensions corresponding to the upscale factor applied to the original image, and pixel values clamped between 0 and 1.
### FunctionDef INPUT_TYPES(s)
**INPUT_TYPES**: The function of INPUT_TYPES is to define the required input types for the image upscaling model.

**parameters**: The parameters of this Function.
· parameter1: s - This parameter is a placeholder that is not used within the function body.

**Code Description**: The INPUT_TYPES function returns a dictionary that specifies the required input types for the image upscaling model. The dictionary contains a single key, "required", which maps to another dictionary. This inner dictionary defines two required inputs: "upscale_model" and "image". Each of these inputs is associated with a tuple that contains a string representing the type of data expected. Specifically, "upscale_model" is expected to be of type "UPSCALE_MODEL", and "image" is expected to be of type "IMAGE". This structured approach allows for clear definition and validation of the inputs needed for the model to function correctly.

**Note**: It is important to ensure that the inputs provided to the model match the specified types in order to avoid errors during processing. The function does not perform any validation or processing of the inputs; it merely defines the expected structure.

**Output Example**: A possible appearance of the code's return value could be:
{
    "required": {
        "upscale_model": ("UPSCALE_MODEL",),
        "image": ("IMAGE",)
    }
}
***
### FunctionDef upscale(self, upscale_model, image)
**upscale**: The function of upscale is to apply an upscale model to an input image, processing it in tiles to manage memory efficiently and prevent out-of-memory errors.

**parameters**: The parameters of this Function.
· upscale_model: The model used for upscaling the image, which must be moved to the appropriate device (CPU or GPU) for processing.
· image: A tensor representing the input image to be upscaled, which is expected to be in a specific format suitable for processing by the upscale model.

**Code Description**: The upscale function is designed to upscale an input image using a specified upscale model while efficiently managing memory through a tiling approach. The function begins by determining the appropriate device (CPU or GPU) for processing using the model_management.get_torch_device() function. The upscale model is then transferred to this device, and the input image is rearranged to match the expected input format of the model.

The function sets parameters for tiling, specifically defining the tile size (512) and the overlap between tiles (32). It enters a loop that continues until the image is successfully processed without encountering an out-of-memory (OOM) exception. Within this loop, the function calculates the total number of processing steps required based on the dimensions of the input image and the tiling parameters using ldm_patched.modules.utils.get_tiled_scale_steps.

A progress bar is instantiated to provide feedback on the processing status. The function then calls ldm_patched.modules.utils.tiled_scale, which processes the image in tiles by applying the upscale model to each tile while managing overlaps. If an OOM exception occurs, the tile size is halved, and the function retries until successful or until the tile size becomes too small (less than 128).

Once the processing is complete, the upscale model is moved back to the CPU, and the output tensor is clamped to ensure pixel values are within the valid range (0 to 1). The function returns the upscaled image as a tensor.

The upscale function is called by the perform_upscale function in the modules/upscaler.py file. In this context, perform_upscale first checks if the upscale model is loaded; if not, it loads the model and prepares it for evaluation. It then converts the input image from a NumPy array to a PyTorch tensor, calls the upscale function to process the image, and finally converts the output tensor back to a NumPy array for further use.

**Note**: It is crucial to ensure that the upscale model is properly initialized and moved to the correct device before calling the upscale function. Additionally, the input image must be formatted correctly to avoid errors during processing.

**Output Example**: A possible return value of the function could be a tensor of shape (1, channels, height * upscale_amount, width * upscale_amount), representing the upscaled image ready for further processing or display.
***
